from __future__ import absolute_import, division, print_function

import sys
from collections import defaultdict
sys.path.append('..')

from perfect_hash import Graph



class NewGraph(Graph):

    def check(self):
        """
        See if vertex values add up to edge values (mod N).
        """
        for vertex in range(self.N):
            for neighbor, edge_value in self.adjacent[vertex]:
                assert (self.vertex_values[vertex] +
                        self.vertex_values[neighbor]) % self.N == edge_value

    def enumerate_trees(self):
        """
        Explore all trees, and enumerate them.  Returns a list mapping
        vertices to thier tree number.
        """
        tree = self.N * [-1]  # -1 unvisited, otherwise the number of tree
        counter = 0

        # Loop over all vertices, taking unvisited ones as roots.
        for root in range(self.N):
            if tree[root] >= 0:
                continue

            # explore tree starting at 'root'
            # Stack of vertices to visit, a list of tuples (parent, vertex)
            tovisit = [(None, root)]
            while tovisit:
                parent, vertex = tovisit.pop()
                tree[vertex] = counter

                # Loop over adjacent vertices, but skip the vertex we arrived
                # here from the first time it is encountered.
                skip = True
                for neighbor, unused_edge_value in self.adjacent[vertex]:
                    if skip and neighbor == parent:
                        skip = False
                        continue

                    if tree[neighbor] >= 0:
                        # We visited here before, so the graph is cyclic.
                        sys.exit('Hmm, graph is cyclic.')

                    tovisit.append((vertex, neighbor))

            counter += 1
        assert all(n >=0 for n in tree)
        return tree

    def set_tree_sizes(self, verbose=False):
        """
        Set the 'size' attribute which is a list mapping vertices
        to the size of the tree that vertex belongs to.
        """
        tree = self.enumerate_trees()

        # maps the tree number to number of vertices within that tree
        treesizes = defaultdict(int)
        for n in tree:
            treesizes[n] += 1

        # maps all vertices to the size of the tree they are within
        self.size = [treesizes[tree[v]] for v in range(self.N)]

        if verbose:
            freq = defaultdict(int)
            for size in treesizes.values():
                freq[size] += 1
            print(' Size   Trees')
            print('--------------')
            for s in sorted(freq):
                print('%5d %5d' % (s, freq[s]))

    def write(self, fo, labels=False, minsize=1):
        fo.write('graph G {\n'
                 '  size = "8,8";\n'
                 '  edge [color="#ff0000"]\n')
        if labels:
            fo.write('  node [color="#a0e0ee", style=filled];\n')

            for vertex, value in enumerate(self.vertex_values):
                if self.size[vertex] < minsize:
                    continue
                fo.write('  { node [label="%i: %i"] v%i }\n' % (
                    vertex, value, vertex))
        else:
            fo.write('  node [color="#3377a0", label="",\n'
                     '        style=filled, shape=circle]\n')

        for vertex in range(self.N):          # edges
            if self.size[vertex] < minsize:
                continue
            for neighbor, edge_value in self.adjacent[vertex]:
                if neighbor > vertex:  continue
                fo.write('  v%i -- v%i%s;\n' %
                         (vertex, neighbor,
                          (' [label="%s: %i"]' % (K[edge_value], edge_value))
                          if labels else ''))
        fo.write('}\n')
        fo.close()


if __name__ == '__main__':
    import sys
    from optparse import OptionParser

    usage = "usage: %prog [options] [PYCODE]"

    description = """\
Given the python code for a perfect hash function which was generated by
perfect_hash.py, e.g. by '$ ../perfect_hash.py animals.txt >animals.py',
this program will create the graph which was used in determining the
perfect hash function.  The input python code may also be given to stdin.
The output is saved as in the .dot format which is used by the Graphviz
tools (see http://www.graphviz.org/) to generate a picture of the graph.
"""

    parser = OptionParser(usage = usage,
                          description = description,
                          prog = sys.argv[0])

    parser.add_option("-l", "--labels",
                      action  = "store_true",
                      help    = "add edge labels")

    parser.add_option("-m", "--minsize",
                      action  = "store",
                      default = 2,
                      type    = "int",
                      help    = "Include only trees in the output which "
                                "have at least INT vertices. "
                                "Default is %default, i.e. all trees are "
                                "included within the output.",
                      metavar = "INT")

    parser.add_option("-o", "--output",
                      action  = "store",
                      help    = "Specify output FILE explicitly. "
                                "Default, is stdout. ",
                      metavar = "FILE")

    parser.add_option("-v", "--verbose",
                      action  = "store_true",
                      help    = "verbosity")

    opts, args = parser.parse_args()

    if len(args) > 1:
        parser.error("incorrect number of arguments")

    # --------------------- end parsing and checking -----------------------

    if opts.verbose:
        sys.stderr.write('minsize (of trees): %i\n' % opts.minsize)
        sys.stderr.write('labels (in output): %s\n' % opts.labels)

    if len(args)==1:
        try:
            fi = open(args[0])
        except IOError:
            sys.exit("Error: Can't open `%s' for reading." % args[0])
    else:
        fi = sys.stdin

    exec(fi.read())

    g = NewGraph(len(G))
    g.vertex_values = G
    for key, hashval in zip(K, H):
        g.connect(hash_f(key, S1), hash_f(key, S2), hashval)
    g.check()
    g.set_tree_sizes(opts.verbose)

    if opts.output:
        try:
            fo = open(opts.output, 'w')
        except IOError :
            sys.exit("Error: Can't open `%s' for writing." % opts.output)
    else:
        fo = sys.stdout

    g.write(fo, opts.labels, opts.minsize)
